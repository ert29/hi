
 for _,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
        if v:IsA("Accessory") then
            if v.Handle:FindFirstChild("Mesh") then
                v.Handle.Mesh:Destroy()
            else
                v.Handle.SpecialMesh:Destroy()
            end
        end
    end

setfpscap(60)

getgenv()._SETTINGS = {
    NoAnimations = false
}

local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local RemovedInstances = {}

local env = {
	Movement = function(LocalCharacter, ScriptCharacter)
		RunService.Stepped:Connect(function()
			if LocalCharacter.Humanoid.Jump == true then
				ScriptCharacter.Humanoid.Jump = true
			end
		
			ScriptCharacter.Humanoid:Move(LocalCharacter.Humanoid.MoveDirection)
		end)
	end,

    SimulationNet = function(Player, Value)
        RunService.RenderStepped:Connect(function()
            sethiddenproperty(Player, "SimulationRadius", Value)
        end)
    end,

    ClearAnimations = function(Character, Bool)
        if Bool == true then
            for _,Animation in pairs(Character.Humanoid:GetPlayingAnimationTracks()) do
                Animation:Stop()
            end
        end
    end,

    CleanUp = function(Character)
        for _,Instance_ in pairs(Character:GetDescendants()) do
            if Instance_:IsA("Decal") or Instance_:IsA("Part") or Instance_:IsA("MeshPart") then
                Instance_.Transparency = 1
            end
        end
    end,

    NoclipCharacter = function(Character) 
        for _,Instance_ in pairs(Character:GetDescendants()) do
            if Instance_:IsA("Part") or Instance_:IsA("MeshPart") then
                RunService.Stepped:Connect(function()
                    Instance_.CanCollide = false
                end)
            end
        end
    end,

    Align = function(Part0, Part1)
		local function vel(Instance_, Character)		
			local Signal = game.RunService.Heartbeat:connect(function()
				Instance_.Velocity = Vector3.new(-62.89786648237, 0, -62.89786648237)
			end)
		end

		local Attachment0 = Instance.new("Attachment", Part0)
		local Attachment1 = Instance.new("Attachment", Part1)

		local AlignPosition = Instance.new("AlignPosition", Part0)
		local AlignOrientation = Instance.new("AlignOrientation", Part0)
		
		AlignPosition.MaxForce = 9e9
		AlignPosition.Responsiveness = 200
		AlignOrientation.MaxTorque = 9e9
		AlignOrientation.Responsiveness = 200

		AlignPosition.Attachment0 = Attachment0
		AlignPosition.Attachment1 = Attachment1
		AlignOrientation.Attachment0 = Attachment0
		AlignOrientation.Attachment1 = Attachment1

		if Part0.Name == "Handle" then
			Part0:BreakJoints()

			Attachment0.Position = Vector3.new(0, 0, 0)
			Attachment0.Orientation = Vector3.new(90, 0, 0)

			if Part0.Parent.Name == "Pal Hair" then
				Part0.Mesh:Destroy()
			end
		else
			Attachment0.Position = Vector3.new(0, 0, 0)
			Attachment0.Orientation = Vector3.new(0, 0, 0)
		end

		vel(Part0, game.Players.LocalPlayer.Character)
	end,

    UnAnchorCharacter = function(Character)
        for _,Instance_ in pairs(Character:GetDescendants()) do
            if Instance_:IsA("Part") or Instance_:IsA("MeshPart") then
                Instance_.Anchored = false
            end
        end
    end,

	ClearWelds = function(Character)
		local Welds = {
			RightArm = Character.Torso["Right Shoulder"],
			RightLeg = Character.Torso["Right Hip"],
			LeftArm = Character.Torso["Left Shoulder"],
			LeftLeg = Character.Torso["Left Hip"],
			Torso = Character.HumanoidRootPart.RootJoint
		}

		for _,Weld in pairs(Welds) do
			Weld:Remove()
		end
	end,

	Cframe = function(Part0, Part1, Methods)
		local Cframe = game.RunService["Heartbeat"]:Connect(function()
			Part0.CFrame = Part1.CFrame
		end)

		if not Part0 then
			Cframe:disconnect()
			Cframe = nil
		end
	end,

	Remove = function(Part)
		table.insert(RemovedInstances, Part.Name)

		Part:Destroy()
	end,

	setCamera = function(Part)
		Workspace.Camera.CameraSubject = Part
	end,

	bodyCollision = function(Humanoid)
		Humanoid:ChangeState(16)
	end
}

local LocalPlayer = Players.LocalPlayer
local LocalCharacter = LocalPlayer.Character
local Animate = LocalCharacter.Animate
local Humanoid = LocalCharacter.Humanoid
local HumanoidRootPart = LocalCharacter.HumanoidRootPart

LocalCharacter.Archivable = true

local ScriptCharacter = LocalCharacter:Clone()
ScriptCharacter.Name = "ScriptCharacter"
ScriptCharacter.Parent = LocalCharacter

env.CleanUp(ScriptCharacter)
env.NoclipCharacter(ScriptCharacter)
env.NoclipCharacter(LocalCharacter)
env.UnAnchorCharacter(ScriptCharacter)
env.UnAnchorCharacter(LocalCharacter)
env.SimulationNet(LocalPlayer, 1000)
env.ClearWelds(LocalCharacter)
env.Remove(LocalCharacter["HumanoidRootPart"])
env.Movement(LocalCharacter, ScriptCharacter)
env.setCamera(ScriptCharacter.Humanoid)
env.bodyCollision(LocalCharacter.Humanoid)

if _SETTINGS.NoAnimations == true then
    env.ClearAnimations(ScriptCharacter, true)
end

env.Align(LocalCharacter["Torso"], ScriptCharacter["Torso"])
env.Align(LocalCharacter["Left Arm"], ScriptCharacter["Left Arm"])
env.Align(LocalCharacter["Left Leg"], ScriptCharacter["Left Leg"])
env.Align(LocalCharacter["Right Arm"], ScriptCharacter["Right Arm"])
env.Align(LocalCharacter["Right Leg"], ScriptCharacter["Right Leg"])

local FlingPart = nil

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

speed = 1
sine = 1
srv = game:GetService('RunService')

function hatset(yes,part,c1,c0,nm)
reanim[yes].Handle.AccessoryWeld.Part1=reanim[part]
reanim[yes].Handle.AccessoryWeld.C1=c1 or CFrame.new()
reanim[yes].Handle.AccessoryWeld.C0=c0 or CFrame.new()--3bbb322dad5929d0d4f25adcebf30aa5
if nm==true then
for i,v in next, workspace[game.Players.LocalPlayer.Name][yes].Handle:GetDescendants() do
if v:IsA('Mesh') or v:IsA('SpecialMesh') then
v:Remove()
end
end
end
end

function setuptrail(parent,Pos1,Pos2,Color,LT,LE,Texture)
IT = Instance.new
local Part1 = parent
local A1 = IT("Attachment",Part1)
A1.Position = Pos1
A1.Name = "ATH10"
local B1 = IT("Attachment",Part1)
B1.Position = Pos2
B1.Name = "ATH11"
local Trail1 = IT("Trail",Part1)
Trail1.Name = "Nexo Trail"
Trail1.Color = Color
Trail1.Attachment0 = B1
Trail1.Attachment1 = A1
Trail1.Lifetime = LT
Trail1.LightEmission = LE
Trail1.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0, 0),NumberSequenceKeypoint.new(1, 1)})
Trail1.Texture = Texture
Trail1.Enabled = true
end

--                          |
--put the setup trail below v

--put the hat script converted below

reanim = game.Players.LocalPlayer.Character
RJ = reanim.HumanoidRootPart.RootJoint
RS = reanim.Torso['Right Shoulder']
LS = reanim.Torso['Left Shoulder']
RH = reanim.Torso['Right Hip']
LH = reanim.Torso['Left Hip']
Root = reanim.HumanoidRootPart
NECK = reanim.Torso.Neck
NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
NECK.C1 = CF(0,-0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C1 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C1 = CF(-0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C1 = CF(0.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

coroutine.wrap(function()
while true do -- anim changer
if HumanDied then break end
sine = sine + speed
if Root.Velocity.y > 1 then -- jump
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.sin(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.75+0.05*math.sin(sine/10),-0.8+0*math.cos(sine/13))*ANGLES(RAD(-10+0*math.sin(sine/13)),RAD(-20+0*math.cos(sine/13)),RAD(-60+0*math.sin(sine/13))),.1)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.4+0.05*math.sin(sine/10),0+0*math.cos(sine/13))*ANGLES(RAD(4+0*math.sin(sine/13)),RAD(4+0*math.cos(sine/13)),RAD(-5+0*math.sin(sine/13))),.1)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/37),-1+0*math.cos(sine/88),0+0*math.cos(sine/90))*ANGLES(RAD(0+-45*math.sin(sine/5)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+45*math.sin(sine/5)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
elseif Root.Velocity.y < -1 then -- fall
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.sin(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.75+0.05*math.sin(sine/10),-0.8+0*math.cos(sine/13))*ANGLES(RAD(-10+0*math.sin(sine/13)),RAD(-20+0*math.cos(sine/13)),RAD(-60+0*math.sin(sine/13))),.1)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.4+0.05*math.sin(sine/10),0+0*math.cos(sine/13))*ANGLES(RAD(4+0*math.sin(sine/13)),RAD(4+0*math.cos(sine/13)),RAD(-5+0*math.sin(sine/13))),.1)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/37),-1+0*math.cos(sine/88),0+0*math.cos(sine/90))*ANGLES(RAD(0+-45*math.sin(sine/5)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+45*math.sin(sine/5)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
elseif Root.Velocity.Magnitude < 2 then -- idle
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.sin(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.75+0.05*math.sin(sine/10),-0.8+0*math.cos(sine/13))*ANGLES(RAD(-10+0*math.sin(sine/13)),RAD(-20+0*math.cos(sine/13)),RAD(-60+0*math.sin(sine/13))),.1)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.4+0.05*math.sin(sine/10),0+0*math.cos(sine/13))*ANGLES(RAD(4+0*math.sin(sine/13)),RAD(4+0*math.cos(sine/13)),RAD(-5+0*math.sin(sine/13))),.1)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(-10+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(10+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
elseif Root.Velocity.Magnitude < 20 then -- walk
NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.sin(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.75+0.05*math.sin(sine/10),-0.8+0*math.cos(sine/13))*ANGLES(RAD(-10+0*math.sin(sine/13)),RAD(-20+0*math.cos(sine/13)),RAD(-60+0*math.sin(sine/13))),.1)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.4+0.05*math.sin(sine/10),0+0*math.cos(sine/13))*ANGLES(RAD(4+0*math.sin(sine/13)),RAD(4+0*math.cos(sine/13)),RAD(-5+0*math.sin(sine/13))),.1)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/37),-1+0*math.cos(sine/88),0+0*math.cos(sine/90))*ANGLES(RAD(0+-45*math.sin(sine/5)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+45*math.sin(sine/5)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
elseif Root.Velocity.Magnitude > 20 then -- run

hatset('MeshPartAccessory','Torso',CFrame.new(),reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/250),0+0*math.cos(sine/250),-8+0*math.cos(sine/250))*ANGLES(RAD(0+0*math.cos(sine/250)),RAD(0+0*math.cos(sine/250)),RAD(0+360*math.cos(sine/250))),1),true)

NECK.C0 = NECK.C0:Lerp(CF(0+0*math.cos(sine/13),1+0*math.sin(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
RJ.C0 = RJ.C0:Lerp(CF(0+0*math.cos(sine/13),0+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+0*math.sin(sine/13)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
RS.C0 = RS.C0:Lerp(CF(1+0*math.cos(sine/13),0.75+0.05*math.sin(sine/10),-0.8+0*math.cos(sine/13))*ANGLES(RAD(-10+0*math.sin(sine/13)),RAD(-20+0*math.cos(sine/13)),RAD(-60+0*math.sin(sine/13))),.1)
LS.C0 = LS.C0:Lerp(CF(-1+0*math.cos(sine/13),0.4+0.05*math.sin(sine/10),0+0*math.cos(sine/13))*ANGLES(RAD(4+0*math.sin(sine/13)),RAD(4+0*math.cos(sine/13)),RAD(-5+0*math.sin(sine/13))),.1)
RH.C0 = RH.C0:Lerp(CF(0.5+0*math.cos(sine/37),-1+0*math.cos(sine/88),0+0*math.cos(sine/90))*ANGLES(RAD(0+-45*math.sin(sine/5)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
LH.C0 = LH.C0:Lerp(CF(-0.5+0*math.cos(sine/13),-1+0*math.cos(sine/13),0+0*math.cos(sine/13))*ANGLES(RAD(0+45*math.sin(sine/5)),RAD(0+0*math.cos(sine/13)),RAD(0+0*math.sin(sine/13))),.1)
end

reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0 = reanim['MeshPartAccessory'].Handle.AccessoryWeld.C0:Lerp(CF(0+0*math.cos(sine/250),0+0*math.cos(sine/250),-8+0*math.cos(sine/250))*ANGLES(RAD(0+0*math.cos(sine/250)),RAD(0+0*math.cos(sine/250)),RAD(0+360*math.cos(sine/250))),.1)

srv.RenderStepped:Wait()
end
end)()
--Created using Nexo Animator
